{% extends "base.html" %}

{% block content %}
<div>
    
    <h3 style="margin-top: 0;">Login</h3>

    <form id="loginForm" action="" method="post" novalidate>
        {{ form.hidden_tag() }}

        <div style="margin-bottom: 15px;">
            {{ form.username.label }}<br>
            {{ form.username(id="username", size=32) }}
        </div>

        <div style="margin-bottom: 15px;">
            <label for="password_raw" class="form-label">Password</label>
            <br>
            <input type="password" id="password_raw" class="form-control" autocomplete="password">
            <br>
            <a href="{{ url_for('auth.reset_password') }}">Reset Password</a>
        </div>
        
        <div style="margin-bottom: 15px;">
            {{ form.totp_code.label }}<br>
            {{ form.totp_code(placeholder="000000", autocomplete="off") }}
        </div>

        <div>
            {{ form.submit(id="submitBtn") }}
        </div>

        {{form.password_verifier(id="password_verifier") }}
        
        <div id="statusMessage" style="margin-top: 10px; font-weight: bold; color: blue;"></div>
    </form>
</div>

<script>

    document.getElementById('loginForm').addEventListener('submit', async function(event) {
        event.preventDefault();

        const username = document.getElementById('username').value;
        const plainPassword = document.getElementById('password_raw').value;
        const statusMsg = document.getElementById('statusMessage');
        const submitBtn = document.getElementById('submitBtn');
        const totp_code = document.getElementById('totp_code').value

        try {
            if (!plainPassword || !username || !totp_code) {
                throw new Error("Login, password and 2FA are required!");
            }
            statusMsg.innerText = "Verification";
            submitBtn.disabled = true;

            const salt = await getSaltFromUsername(username);

            const secrets = await deriveSecrets(plainPassword, salt);

            const formData = new FormData(this);
            formData.set('password_verifier', secrets.loginToken);

            const response = await fetch(this.action, {
                method: 'POST',
                body: formData
            });

            const result = await response.json();

            if (!result.success) {
                throw new Error(result.message);
            }

            const keys = result.keys;

            const ivEnc = base64ToArrayBuffer(keys.private_key_iv);
            const encPrivBlob = base64ToArrayBuffer(keys.encrypted_private_key);
            const encPrivKeyObj = await window.crypto.subtle.unwrapKey(
                "pkcs8", encPrivBlob, secrets.encryptionKey,
                { name: "AES-GCM", iv: ivEnc },
                { name: "X25519" },
                true, ["deriveKey", "deriveBits"]
            );
            const expEncKey = await window.crypto.subtle.exportKey("jwk", encPrivKeyObj);
            sessionStorage.setItem("dec_enc_key", JSON.stringify(expEncKey));

            const ivSign = base64ToArrayBuffer(keys.signing_private_key_iv);
            const signPrivBlob = base64ToArrayBuffer(keys.encrypted_signing_private_key);
            const signPrivKeyObj = await window.crypto.subtle.unwrapKey(
                "pkcs8", signPrivBlob, secrets.encryptionKey,
                { name: "AES-GCM", iv: ivSign },
                { name: "Ed25519" },
                true, ["sign"]
            );
            const expSignKey = await window.crypto.subtle.exportKey("jwk", signPrivKeyObj);
            sessionStorage.setItem("dec_sign_key", JSON.stringify(expSignKey));
            window.location.href = result.redirect_url;

        } catch (err) {
            console.error(err);
            statusMsg.innerText = "Error: " + err.message;
            statusMsg.style.color = "red";
            submitBtn.disabled = false;
            password.value = "";
        }
    });
</script>
{% endblock %}